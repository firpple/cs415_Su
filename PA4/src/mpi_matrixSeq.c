/******************************************************************************
* FILE: mpi_matrixSeq.c
* DESCRIPTION:
*   Calculates the matrix sequential. Prints the execution time
*
* Usage:
*   $ srun -n<cores> mpi_matrixSequential <size> <file1> <file2>
*   $ #to read numbers in from file, set size to 0
*   $ #to generate numbers at rand(predetermined), set size > 0
*
* AUTHOR: Evan Su
* LAST REVISED: 04/5/17
******************************************************************************/

//libraries
#include "mpi.h"
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>

//define constants
#define  MASTER        0
#define  SLAVE      1
#define  TAG        0
#define  SECTOMICRO 1000000
#define  PRINT      0
#define     PRINTMATRIX    1
#define  RANGE        100


/*function declarations*******************************************************/

/*
 *  Function name: masterCode
 *  
 *  Brief: matrix multiplication for the master node
 */
void masterCode(int, char*, char*);

/*
 *  Function name: slaveCode
 *  
 *  Brief: matrix multiplication code for the slave node
 */
void slaveCode(int,int);


/*
 *  Function name: matrixMultipleSquare
 *  
 *  Brief: matrix multiplication two matrixes and stores into the results
 */
void matrixMultipleSquare(int **, int**, int**, int);


/*
 *  Function name: printMatrix
 *  
 *  Brief: prints the matrix
 */
void printMatrix(int **, int );


/*
 *  Function name: makeMatrix
 *  
 *  Brief: make Matrix
 */
int ** makeMatrix(int);


/*
 *  Function name: freeMatrix
 *  
 *  Brief: frees Matrix memory
 */
void freeMatrix(int**, int);


/*
 *  Function name: fillMatrix
 *  
 *  Brief: fills matrixA and B with numbers
 */  
void fillMatrix(int**, int**, int);


/*
 *  Function name: readMatrix
 *  
 *  Brief: fills matrixA and matrixB from files
 */
void readMatrix(int**, int**, int, FILE *, FILE *);


/*function declarations*******************************************************/


//Main function
/*
 *  Function name: main
 *  
 *  Brief: Main driver for the program
 *  
 *  Detail: The main driver initializes parallel processes.
 *          The master calls the master function
 *          The slave calls the slave function
 *          Both functions will run until computations are over.
 *
 *  Note: The slave functions does nothing, it is a placeholder
 *        for parallel code. 
 *
 *  Parameters:
 *        int argc: number of command line arguements
 *
 *        char *argv[]: command line arguements
 *              argv[1]: size of matrix
 *              argv[2]: file name A
 *              argv[3]: file name B
 *          
 */
int main (int argc, char *argv[])
{
    //argc checker
    if(argc < 2)
    {
        //there are not enough arugments
        //note: this will not check if the arguements are in the correct positions
        printf("not enough arguments\n");
        printf("proper usage:\n srun mpi_BucketSeq <filename> <mpi arguements>");
        return 0;
    }
    
    //preprocessing
    int numtasks, taskid, len;
    char hostname[MPI_MAX_PROCESSOR_NAME];

    //parallel start
    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &numtasks);
    MPI_Comm_rank(MPI_COMM_WORLD,&taskid);
    MPI_Get_processor_name(hostname, &len);


    if (taskid == MASTER)
    {
        //master code
        masterCode(atoi(argv[1]), argv[2], argv[3]);
    }
    else
    {
        //slave code
        //this code does nothing, placeholder for parallel.
        slaveCode(atoi(argv[1]), taskid);
    }

    MPI_Finalize();
    return 0;



}

/*
 *  Function name: masterCode
 *  
 *  Brief: matrix multiplication for the master node
 *  
 *  Detail: Makes matrixs based on size entered 
 *          If the size is greater than zero, the matrix
 *          are generated by the program
 *          else read from file 
 *          
 *          matrix multiple the two files
 *          
 *          prints the results
 *
 *  Parameters:
 *        int size: length of matrix
 *
 *        char * fileA: name of file of matrix 1 
 *
 *        char * fileB: name of file of matrix 2
 *
 *  notes: the function will only read from file if size is 0 or less.
 */
void masterCode(int size, char * fileA, char * fileB)
{
    struct timeval startTime, endTime, diffTime;
    float elapsedTime = 0;
    int **matrixA, **matrixB, **matrixC;
    int scanResult;
    //int indexIn, indexOut;
    FILE * finA, * finB;
    srand(0);

    //fill matrix
    if(size > 0)
    {
        //make matrix
        matrixA = makeMatrix(size);
        matrixB = makeMatrix(size);
        matrixC = makeMatrix(size);
        //fill matrix
        fillMatrix(matrixA, matrixB, size);
    }
    else
    {
        //open files
        finA = fopen(fileA,"r");
        finB = fopen(fileB,"r");

        //scans the size
        scanResult = fscanf(finA, "%d", &size);
        scanResult = fscanf(finB, "%d", &size);        
        if(scanResult == 0)
        {
            //issues with the scan
            printf("read error\n");
            fclose(finA);
            fclose(finB);
            //exits
            return;
        }

        //make matrix
        matrixA = makeMatrix(size);
        matrixB = makeMatrix(size);
        matrixC = makeMatrix(size);

        //fill matrix from file
        readMatrix(matrixA, matrixB, size, finA, finB);
        
        //close files
        fclose(finA);
        fclose(finB);
    }

    //start time
    gettimeofday(&startTime, NULL);

    //matrix multiplication
    matrixMultipleSquare(matrixA, matrixB, matrixC, size);

    //stop time
    gettimeofday(&endTime, NULL);

     //calc diff time
    timersub(&endTime, &startTime, &diffTime);
    //converts time struct to float
    elapsedTime = (diffTime.tv_sec * SECTOMICRO + diffTime.tv_usec); 
    //prints result in microseconds
    printf("%f,",elapsedTime );

    //print matrixs
    if(PRINTMATRIX)
    {
        //new line the results
        printf("\n");

        //matrix A
        printf("matrix A:\n");
        printMatrix(matrixA, size);

        //matrix B
        printf("matrix B:\n");
        printMatrix(matrixB, size);

        //matrix C
        printf("matrix C:\n");
        printMatrix(matrixC, size);
    }

    //free memory
    freeMatrix(matrixA, size);
    matrixA = NULL;

    freeMatrix(matrixB, size);
    matrixB = NULL;

    freeMatrix(matrixC, size);
    matrixC = NULL;
}

/*
 *  Function name: slaveCode
 *  
 *  Brief: matrix multiplication code for the slave node
 *  
 *  Detail: The slave node does nothing in sequential calculations
 *  
 *  parameters:
 *        int size: length of matrix
 *
 *        int rank: rank of the slave
 *  
 *  
 */
void slaveCode(int size, int rank)
{
    //printf("hello from slave");
}

/*
 *  Function name: matrixMultipleSquare
 *  
 *  Brief: matrix multiplication two matrixes and stores into the results
 *  
 *  Detail: matrix multiples matrixA and matrixB. Stores result in matrixResults
 *          by adding the values to the matrixResults.
 *
 *  Parameters:
 *        int ** matrixA: first matrix multplicand
 *
 *        int ** matrixB: second matrix multplicand
 *
 *        int ** matrixResult: product matrix
 *
 *        int length: length of the matrix
 *
 *  Notes: The matrix must be initilized and pointing to a 2d array
 */
void matrixMultipleSquare(int **matrixA, int**matrixB, int**matrixResult, int length)
{
    int indexIn, indexOut, indexSub;

    for(indexOut = 0; indexOut < length; indexOut++)
    {
        for(indexIn = 0; indexIn < length; indexIn++)
        {
            for(indexSub = 0; indexSub < length; indexSub++)
            {
                //adds the results to the matrixresult
                matrixResult[indexOut][indexIn] += 
                        matrixA[indexOut][indexSub]*matrixB[indexSub][indexIn];
            }
        }
    }
}

/*
 *  Function name: printMatrix
 *  
 *  Brief: prints the matrix
 *  
 *  Detail: prints matrix using a for loop
 *
 *  Parameters:
 *        int **matrix: matrix to print
 *
 *        int length: length of the matrix
 */
void printMatrix(int **matrix, int length)
{
    int indexIn, indexOut;

    for(indexOut = 0; indexOut < length; indexOut++)
    {
        for(indexIn = 0; indexIn < length; indexIn++)
        {
            printf("%8d", matrix[indexOut][indexIn]);
        }
        printf("\n");
    }
}

/*
 *  Function name: makeMatrix
 *  
 *  Brief: make Matrix
 *  
 *  Detail: makes the matrix of size*size using calloc and malloc
 *
 *  Parameters:
 *        int size: length of the matrix
 */
int ** makeMatrix(int size)
{
    int index;
    int **tempPtr;

    tempPtr = (int **)malloc(sizeof(int*) * size);    
    for (index = 0; index < size; index ++)
    {
        tempPtr[index] = (int*)calloc(size ,sizeof(int));
    }
    return tempPtr;
}

/*
 *  Function name: freeMatrix
 *  
 *  Brief: frees Matrix memory
 *  
 *  Detail: frees the matrix memory
 *  Parameters:
 *        int **matrix: matrix to free
 *
 *        int size: length of the matrix
 */
void freeMatrix(int ** matrix, int size)
{
    int index;
    for(index = 0; index < size; index++)
    {
        free(matrix[index]);
    }
    free(matrix);
}

/*
 *  Function name: fillMatrix
 *  
 *  Brief: fills matrixA and B with numbers
 *  
 *  Detail: fills matrixA and matrixB with rand()
 *
 *  Parameters:
 *        int **matrixA: matrix 1 to fill
 *
 *        int **matrixB: matrix 2 to fill
 *
 *        int size: length of the matrix
 *
 *  Notes:  srand must be seeded before the function call
 */
void fillMatrix(int** matrixA, int **matrixB, int size)
{
    int indexOut, indexIn;

    for(indexOut = 0; indexOut < size; indexOut++)
    {
        for(indexIn = 0; indexIn < size; indexIn++)
        {
            //fills matrix of A and B at [indexOut][indexIn] with rand numbers
            matrixA[indexOut][indexIn] = rand() %RANGE;
            matrixB[indexOut][indexIn] = rand() %RANGE;
        }
    }
}

/*
 *  Function name: readMatrix
 *  
 *  Brief: fills matrixA and matrixB from files
 *  
 *  Detail: matrixA is filled with numbers from finA 
 *          matrixB is filled with numberes from finB
 *
 *  Parameters:
 *        int **matrixA: matrix 1 to fill
 *
 *        int **matrixB: matrix 2 to fill
 *
 *        int size: length of the matrix
 *
 *        FILE * finA: pointer to the matrix 1 data
 *
 *        FILE * finB: pointer to the matrix 2 data
 *
 *  Notes:  finA and finB must point to a file before using this function
 */
void readMatrix(int** matrixA, int** matrixB, int size, FILE * finA, FILE * finB)
{
    int indexIn, indexOut;
    int scanResult;
    
    for(indexOut = 0; indexOut < size; indexOut ++)
    {
        for(indexIn = 0; indexIn < size; indexIn++)
        {
            //reads the numbers into matrixA and matrixB
            scanResult = fscanf(finA, "%d", &matrixA[indexOut][indexIn]);
            scanResult = fscanf(finB, "%d", &matrixB[indexOut][indexIn]);
            if(scanResult == 0)
            {
                //read error
                printf("read error\n");
            }
        }
    }

}
